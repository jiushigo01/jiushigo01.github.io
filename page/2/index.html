<!DOCTYPE html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title></title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title"></span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/react生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/react生命周期/" itemprop="url">react生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T16:05:20+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>react组件的生命周期可以归为三种状态：创建前，存在期，销毁时。</p>
<p>话不多说，盗一张图<br><img src="/image/smzq.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/react为何强大/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/react为何强大/" itemprop="url">react为何强大</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T15:08:07+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>打个不恰当的比喻，前端好比盖房子，HTML是骨架，css用来搞装修，js用来实现房子的各种功能。<br>以前盖一所房子呢，要打地基，砌墙，粉刷等等一系列步骤。人们觉得太繁琐，于是想出了一个主意，把房子像积木一样一个一个拆出来，要盖房子的时候，再一个一个组装起来。</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>react可以将页面做成一个一个的组件，然后再拼装成一个页面。这实现了组件的复用。</p>
<h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>react的每一个组件都是是一个<code>状态机</code>，组件有什么样的数据，就会呈现什么样的UI。这便是数据驱动。我们只需关心数据怎么改变。数据驱动保证了组件了可控性和可预见性，进而保证整个页面的可控性与可预见性。</p>
<h3 id="性能优越"><a href="#性能优越" class="headerlink" title="性能优越"></a>性能优越</h3><p>通过组件嵌套实现的页面，并不会因为其中的一个组件的变化，而将整个页面重载，仅仅只需将变化的那一部分更新。那react是怎么做到的呢？这不得不说到diff算法。</p>
<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>浏览器的资源消耗，绝大部分在页面的绘制阶段。传统的页面更新，更新的是实际的DOM节点。而react的状态更新之后，会在内存中生成一个虚拟的DOM，React操作的是虚拟DOM，虚拟DOM实际上就是js画出来的一个画面，存在于内存。直接操作这个画出来的东西，不需要进行dom渲染，所以无论多么频繁操作虚拟dom，速度都很快。当所有操作结束的时候，react才隐式的把虚拟dom渲染成真的dom，这个过程用户根本看不到。diff算法只是比对虚拟dom的不同，并不去关注真实dom到底什么样，只是在最后的时候渲染一个真实的dom。</p>
<h4 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h4><p>比较内存中的虚拟DOM与真实的DOM，找出其中的差别，然后更新真实的DOM，react使用了diff算法。<br>首先比对DOM树的节点，然后比较节点的属性，然后比较节点属性的属性值，如果有任何不同，都会将其节点及其子节点整个替换掉。<br>react不会移动dom，只会删除和创建dom。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/17/原型与原型链/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/17/原型与原型链/" itemprop="url">原型与原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-17T09:19:07+08:00">
                2018-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>初学者对于原型与原型链很难理清楚，是因为这里面有太多的概念。原型，原型链，对象，原型对象，面向对象，实例，普通函数，构造函数，函数对象，引用，prototype，constructor，new，__proto__等等，脑子不炸才怪。<br>不要害怕，这些东西我不会都讲，因为我也没记住 :)</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><blockquote>
<p>JavaScript 中的所有事物都是对象：字符串、数字、数组、日期，等等。<br>在 JavaScript 中，对象是拥有属性和方法的数据。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明一个函数 fn</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>函数 fn 也是一个对象</p>
<h3 id="原型-amp-原型对象"><a href="#原型-amp-原型对象" class="headerlink" title="原型 &amp; 原型对象"></a>原型 &amp; 原型对象</h3><p>函数 fn 也是一个对象，它有一个默认的属性，就是prototype，它就是fn的<code>原型</code><br>prototype的值是一个对象，它就是<code>原型对象</code>。其中有一个默认是属性，constructor<br>constructor是fn的 <a href="/2018/06/16/模块化/#引用"><code>引用</code></a>，即<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明一个函数 fn</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn.prototype = &#123;</span></span><br><span class="line"><span class="comment">//    constructor: fn</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>既然fn的prototype是一个对象，那我们就可以往里面添加属性和属性值啊</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明一个函数 fn</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fn.prototype.a = <span class="string">'123'</span>;</span><br><span class="line">fn.prototype.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** fn.prototype = &#123;</span></span><br><span class="line"><span class="comment">*     constructor: fn,</span></span><br><span class="line"><span class="comment">*     a: '123';</span></span><br><span class="line"><span class="comment">*     b: function () &#123; return 'b' &#125;</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>那这样做有什么用呢？看下面代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明一个函数 fn</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fn.prototype.a = <span class="string">'123'</span>;</span><br><span class="line">fn.prototype.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** fn.prototype = &#123;</span></span><br><span class="line"><span class="comment">*     constructor: fn,</span></span><br><span class="line"><span class="comment">*     a: '123';</span></span><br><span class="line"><span class="comment">*     b: function () &#123; return 'b' &#125;</span></span><br><span class="line"><span class="comment">*   &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> fn();</span><br></pre></td></tr></table></figure>
<p>我们通过new一个fn，得到了fn1，那fn1和fn有什么关系呢？<br>实际上是fn1有了fn原型对象上的方法，即fn1继承了fn的原型对象。（<em>我们可以通过fn1.__proto__查看到继承了哪些东西，fn1.__proto__指向的就是是fn.prototype</em>）<br>现在，我们就可以使用 fn1.a 获得 ‘123’，使用 fn1.b 获得 ‘b’ 啦。<br>那这样又有什么卵用呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明一个函数 fn</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> fn(<span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> fn(<span class="string">'李四'</span>);</span><br><span class="line">fn1.getName(); <span class="comment">// 张三</span></span><br><span class="line">fn2.getName(); <span class="comment">// 李四</span></span><br></pre></td></tr></table></figure>
<p>我们可以把一些共用的方法，放到prototype里，这样就形成一个类。<br>如果还不明白，可以想一想js中的<code>new Date()</code> 或 <code>new Array</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 为什么 d 现在有了 getTime 方法？</span></span><br><span class="line"><span class="comment">* 就是因为Date的prototype中有一个getTime方法，它继承过来了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>还是这个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 为什么 d 现在有了 getTime 方法？</span></span><br><span class="line"><span class="comment">* 就是因为Date的prototype中有一个getTime方法，它继承过来的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>上面例子中，d中没有getTime方法，那么它会向上一层（向创建出它的函数中）查找，在Date.prototype中找到了。即 <code>d.__proto__ === Date.prototype</code>。<br>但是，Date.prototype不就是一个对象吗？既然是对象，那Date.prototype的__proto__指向的是谁的prototype呢？<br>答案是Function的。那Function.prototype也是一个对象，它的__proto__指向的是谁的prototype呢？<br>答案是Object的。那Object.prototype也是一个对象，它的__proto__指向的是谁的prototype呢？<br>答案是Object.prototype的__proto__指向了null。它没有指向谁的prototype。<br>万物之源始于null</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/洋葱模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/洋葱模型/" itemprop="url">洋葱模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T17:30:04+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>express 和 koa 的最大的区别，在于其中间件组织方式的不同。<br>express中，一个中间件全部执行完之后，才会去执行下一个中间件。而在koa中，中间件A执行到一半，可以去执行B中间件，B中间件一样，还可以再嵌套一个C中间件，C执行完了，再执行B剩下的没执行的代码，等到B执行完了，再执行A剩下没执行的代码。这就是著名的洋葱模型。</p>
<p><img src="/image/yangcong.png" alt=""></p>
<p>koa与express的另一个不同之处在于，koa将请求体与响应体放在同一个对象中，即ctx。而express中，req和res是两个入参。还有egg基于koa，所以egg的中间件流程和koa一样，egg与koa的不同，是egg集成了Model和Controller。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/前端路由初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/前端路由初探/" itemprop="url">前端路由初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T16:46:47+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>简单来说，前端路由，就是改变url，却不会引起页面重载。只要做到这两点，就可以实现前端路由。<br>前端路由有两种方式。hash和HTML5的History API</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>URL中 # 后面的部分便是hash，这和锚点是一样的。实际上，如果页面上有一个id和#后的hash值一样的节点，页面会自动定位到那个节点。当hash值改变的时候，将会触发hashChange事件。我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>有这样两个API，<code>history.pushState</code> 和 <code>history.replaceState</code><br>它们接收三个参数 (state, title, url)</p>
<p>比如，我们从 <code>example.com/a</code>， 使用history.pushState({a: 1}, null, ‘example.com/a/b’)，此时url已经变成了 <code>example.com/a/b</code>，但是也没没有刷新，仅仅是多了一条历史记录。replaceState和pushState区别不是新增一条历史记录，而是更改本条历史记录。<br>同样的，这个url的变化会也触发一个事件 <code>popstate</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/webpack初步/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/webpack初步/" itemprop="url">webpack初步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T16:11:42+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h3><blockquote>
<p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。</p>
</blockquote>
<!-- 随着用户对产品的体验要求越来越高，在前端项目中，代码量也越来越大，js及css等有了长足发展 -->
<p>通俗的将，就是将项目中的各种使用ES6的js文件，scss或less，图片等，经过编译和打包，得到一个浏览器可以直接执行的js或者css文件。</p>
<h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><blockquote>
<p>npm i webpack -g</p>
</blockquote>
<p>webpack.config.js配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//入口文件配置</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">        a: <span class="string">"./a"</span>, <span class="attr">b</span>: <span class="string">"./b"</span> </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//出口文件输出配置</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: <span class="string">'dist/js/page'</span>,<span class="comment">//打包文件存放的绝对路径</span></span><br><span class="line">        filename: <span class="string">'[name].js'</span>，<span class="comment">//打包后的文件名</span></span><br><span class="line">        publicPath：<span class="string">"/public"</span> <span class="comment">//网站运行时的访问路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="built_in">module</span>: &#123;</span><br><span class="line">        <span class="comment">//加载器配置，需要npm install *-loader</span></span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">//.css 文件使用 style-loader 和 css-loader 来处理</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: <span class="string">'style-loader!css-loader'</span> &#125;,</span><br><span class="line">            <span class="comment">//.js 文件使用 jsx-loader 来编译处理</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">'jsx-loader?harmony'</span>,<span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;,<span class="comment">//exclude排除</span></span><br><span class="line">            <span class="comment">//.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: <span class="string">'style!css!sass?sourceMap'</span>&#125;,</span><br><span class="line">            <span class="comment">//图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span></span><br><span class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>, <span class="attr">use</span>: <span class="string">'url-loader?limit=8192'</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插件项</span></span><br><span class="line">    plugins: [<span class="keyword">new</span> webpack.CommonsChunkPlugin(<span class="string">"init.js"</span>) ],<span class="comment">//这个插件可以将多个打包后的资源中的公共部分打包成单独的文件，这里指定公共文件输出为“init.js” 生成文件：init.js,a.js,b.js</span></span><br><span class="line">    <span class="comment">//其它解决方案配置</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        <span class="comment">//查找module的话从这里开始查找</span></span><br><span class="line">        root: <span class="string">'E:/github/flux-example/src'</span>, <span class="comment">//绝对路径</span></span><br><span class="line">        <span class="comment">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></span><br><span class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.scss'</span>],</span><br><span class="line">        <span class="comment">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></span><br><span class="line">        alias: &#123;</span><br><span class="line">            AppStore : <span class="string">'js/stores/AppStores.js'</span>,<span class="comment">//后续直接 require('AppStore') 即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/垃圾回收机制/" itemprop="url">垃圾回收机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T15:26:02+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>js的变量会在内存中申请一块地址。变量越来越多，占据的内存资源也就越来越多，如果资源一直没有被释放，最终会造成内存泄漏。js的垃圾回收，就是找出不再使用的变量，然后释放其占用的内存。js具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。<br>到此为止，我们的任务就是找出哪些变量不会再被使用。全局变量直到页面卸载才会被清除，我们不去管它。我们需要关心的，是对局部变量的判断。常用的策略有两种，标记清除 &amp; 引用计数。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>这是js最常见的垃圾回收机制。当变量进入执行环境的时候，垃圾回收器会给这个变量打个标记“进入环境”，离开时会标记“离开环境”。垃圾回收器不会清除还在执行环境中的变量。当垃圾回收器执行垃圾回收操作的时候，会给所有变量打上标记“清除”，然后将环境中的变量，以及环境中变量引用的变量的“清除”标记去掉，剩下的还带着标记的，全部回收。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>废话不多说，直接上代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'123'</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 申明一个变量a，它的值为'123'，这个时候，a指向一块内存地址，这个地址中存的字符串'123'</span></span><br><span class="line"><span class="comment">* 这个时候，我们就说存着'123'的这块内存的引用数为1,因为有一个变量a指向它</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 申明变量b,b是a的引用，所以b也指向a指向的那一块内存地址，即存着'123'的那一块</span></span><br><span class="line"><span class="comment">* 这个时候，我们就说存着'123'的这块内存的引用数为2,因为又有一个变量b指向它</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line">b = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将a和b的值更改掉，所以它们将不再指向存着'123'的那一块内存地址</span></span><br><span class="line"><span class="comment">* 而是指向了一个新的地址，这个地址存放着null</span></span><br><span class="line"><span class="comment">* 此时，存放'123'的那一块内存，将在下一次垃圾回收的时候被释放掉</span></span><br></pre></td></tr></table></figure></p>
<p>到此为止，你可能会问这样一个问题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line">obj1.a = obj2;</span><br><span class="line">obj2.a = obj1;</span><br></pre></td></tr></table></figure></p>
<p>这两个变量互相引用，那它们所指向的内存，计数永远大于零，那就不会被清除了？<br>是的，不会被清除，除非手动切断它们的互相引用，将obj1.a和obj2.a重新赋值。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>说到垃圾回收机制，我们一般会想到这样一句话，闭包不会被垃圾回收机制回收，大量使用闭包会严重影响性能。</p>
<p>什么是闭包？</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN对闭包的解释</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449934543461c9d5dfeeb848f5b72bd012e1113d15000" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
</ul>
<p>廖雪峰老师的总结很精辟：</p>
<blockquote>
<p>函数作为返回值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fnf = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fns = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> nfns = fnf();</span><br><span class="line"><span class="comment">// nfns是fnf内部函数fns的引用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fnf = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fns1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> fns2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fns1,</span><br><span class="line">        fns2</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> nfns = fnf();</span><br><span class="line"><span class="comment">// nfns = &#123; fns1, fns2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>我的理解是，父函数中定义了子函数，父函数的返回值中，包含子函数，子函数被外部变量所引用，这样就形成了闭包。就是因为返回值中的函数被外部变量说引用，而这个外部变量往往又是一个全局的或作用域比较大的变量，它会长时间停留在执行环境中，所以才会导致闭包不会被垃圾回收机制回收。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/事件机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/事件机制/" itemprop="url">事件机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T13:46:21+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'out'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'mid'</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'in'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们点击in的时候，发生了什么呢？<br>在js中，有各种各样的事件，比如鼠标点击事件，键盘事件等。事件流就是事件发生时，js从页面中接受事件的顺序。<br>当我们点击in时，最开始有反应的是window（<em>尽管要求是从document开始传播，但是浏览器都是从window对象开始捕获对象</em>），接下来是document-&gt;html-&gt;body-div.out-&gt;div.mid-&gt;div.in，到此为止，我们说这一阶段为事件的捕获阶段。捕获阶段之后，事件会再次到达冒泡阶段，冒泡阶段和捕获阶段的方向是相反的。</p>
<p>我们经常看到这样的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.stopPropagation();</span><br><span class="line">e.preventDefault();</span><br></pre></td></tr></table></figure></p>
<p>stopPropagation是用来阻止事件冒泡。如果我们监听了mid的click事件，而又不想在点击in的时候触发mid的click事件，那我们就在in的click事件中写上stopPropagation。<br>preventDefault是用来阻止默认行为的，比如我们点击了一个type=’submit’的按钮，但是又不想让表单提交，因为我们还没有验证，这个时候就可以使用preventDefault阻止。<br>这两个事件的一种暴力实现，就是直接return false…<br>所以初学表单验证者，会看到这样的代码<code>&lt;input type=&#39;submit&#39; onclick=&#39;return false&#39;&gt;</code></p>
<p>更多内容，请参考<a href="https://www.cnblogs.com/starof/p/4066381.html" target="_blank" rel="noopener">starof的文章</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/模块化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangS">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/模块化/" itemprop="url">模块化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-16T11:05:36+08:00">
                2018-06-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是js的模块化"><a href="#什么是js的模块化" class="headerlink" title="什么是js的模块化"></a>什么是js的模块化</h3><p>es6之前，js是没有自带的模块系统的。而随着项目的发展，js的代码会越来越多。这会给项目带来巨大的维护成本，后期开发也越来越难以分工合作。<br>为了解决这个问题，大神们人为的给js加上了模块。使用较多的便是requireJs和seaJs了。</p>
<h3 id="AMD-amp-CMD"><a href="#AMD-amp-CMD" class="headerlink" title="AMD &amp; CMD"></a>AMD &amp; CMD</h3><p>requireJs和seaJs都是为了解决一件事，将js代码模块化。两者选择了不同的实现方式，但是殊途同归。<br>比如现在有一个页面，需要加载D.js，而D.js中的代码需要A.js，B.js，C.js执行完之后才执行。而B.js需要在A.js加载完之后才能执行。requireJs和seaJs分别会怎么处理呢？</p>
<p>先来看requireJs会怎么处理：</p>
<ul>
<li>将每一个js文件作为一个模块</li>
<li>同时去加载A和C这两个js，在A加载完之后，再去加载B.js</li>
<li>将加载好的js放在自执行函数中执行一遍</li>
<li>最后执行D.js</li>
</ul>
<p>requireJs的这些处理过程，被requireJs称为 <strong>AMD</strong> 规范。</p>
<p>seaJs的处理过程和requireJs不太一样：</p>
<ul>
<li>将每一个js文件作为一个模块</li>
<li>同时去加载ABC这三个js</li>
<li>不会立即执行这个三个js文件，而是在D.js文件调用到的时候，才去执行调用到的js。比如，在D中有一个方法fnD，fnD需要调用A中的方法fnA，而fnA又需要调用B中的fnB，则在这个是个，才会去依次执行A和B这两个文件。</li>
</ul>
<p>seaJs的这些处理过程，被seaJs称为 <strong>CMD</strong> 规范。</p>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>requireJs和seaJs都是为了解决浏览器端的js模块化问题而生。而CommonJs，是为了解决nodeJs中的模块问题而生的。它遵循CMD规范。</p>
<h3 id="ES6中的模块化"><a href="#ES6中的模块化" class="headerlink" title="ES6中的模块化"></a>ES6中的模块化</h3><p>为了解决js的模块化问题，es6中已经原生支持js模块了。模块导出时使用export，导入时使用import。写法如下</p>
<p>定义一个模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abcd'</span>;</span><br><span class="line"><span class="keyword">export</span> str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fna1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> fna1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fna2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fna3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>引用时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用export导出的模块，导入时名字需相同，但可以使用as转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; str, obj, fna1, fna2 <span class="keyword">as</span> fnb2 &#125; <span class="keyword">from</span> <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* fnb4就是fna3，因为fna3导出时使用了export defalut。每个模块只能使用一次export defalut</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> fnb4 <span class="keyword">from</span> <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="module-exports-exports-export-export-default"><a href="#module-exports-exports-export-export-default" class="headerlink" title="module.exports | exports | export | export default"></a>module.exports | exports | export | export default</h3><p>module.exports | exports | export | export default的区别有时候很容易搞混。</p>
<h4 id="export-amp-export-default"><a href="#export-amp-export-default" class="headerlink" title="export &amp; export default"></a>export &amp; export default</h4><p>刚刚已经说明了export &amp; export default，这两个是ES6导出模块时使用的，不再赘述。</p>
<h4 id="module-exports-amp-exports"><a href="#module-exports-amp-exports" class="headerlink" title="module.exports &amp; exports"></a>module.exports &amp; exports</h4><p>module.exports &amp; exports是在node中导出模块时使用的。<br>首先，请记住一句话，exports是module.exports的引用，即<code>exports=module.exports</code>。在nodejs中，一个js文件就是一个模块。在每个模块中，都会有一个module对象，这个对象就指向当前的模块。module对象中有一个exports属性，表示当前模块暴露给外部的值。当其他的文件require进来该模块的时候，实际上就是读取了该模块module对象的exports属性。也就是说，真正导出的，是module.exports.</p>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>那什么是引用呢？先来看下面这个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = &#123; <span class="attr">e</span>: &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> es = m.e;</span><br><span class="line">es.name = <span class="string">'qwer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"><span class="comment">// &#123; e: &#123; name: 'qwer' &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(es);</span><br><span class="line"><span class="comment">// &#123; name: 'qwer' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es = m.e 我们就说es是m.e的引用，它们两个其实指向的是同一块内存地址</span></span><br></pre></td></tr></table></figure>
<p>相同的，module.exports是一个对象，它指向内存中的一个地方，而exports是module.exports的引用，它也指向同一块内存地址。当我们这样写代码的时候，是没事的。</p>
<p>定义一个模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.fna1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">exports.fna2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>引用这个模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入a模块</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用a模块的方法</span></span><br><span class="line">a.fna1()</span><br><span class="line">a.fna2()</span><br></pre></td></tr></table></figure></p>
<p>而当我们这样写的时候，那就炸了</p>
<p>eg 1<br>定义一个模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.fna1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">exports.fna2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fna3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这样代码，为module.exports重新申请了一块内存地址，导致导出时，只有fna3方法</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; fna3 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>引用这个模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入a模块</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用a模块的方法</span></span><br><span class="line">a.fna1() <span class="comment">// undefined</span></span><br><span class="line">a.fna2() <span class="comment">// undefined</span></span><br><span class="line">a.fna3() <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure></p>
<p>eg 2<br>定义一个模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.fna1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">exports.fna2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fna3 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面这行代码，为exports重新申请了一块内存地址</span></span><br><span class="line"><span class="comment">* 而modelu.exports指向的内存地址中，仍然有fna1和fna2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">exports = &#123; fna3 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>引用这个模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入a模块</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用a模块的方法</span></span><br><span class="line">a.fna1() <span class="comment">// 正常</span></span><br><span class="line">a.fna2() <span class="comment">// 正常</span></span><br><span class="line">a.fna3() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wangS</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangS</span>

  
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
